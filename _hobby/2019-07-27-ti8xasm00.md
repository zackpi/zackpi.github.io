---
title: Ti84+ Z80 ASM Project Euler 00
description: Story time & Setting up the development environment
date: 2019-07-27 5:58
layout: hobbyproj
---

In high school, I was an avid [Texas Instruments](https://education.ti.com/en/products/calculators/graphing-calculators/ti-84-plus-se) graphing calculator nerd. I loved that you could program them and I spent way too much time with my face buried in my calculator in physics class (sorry, Mr. Felton), writing various programs and drawing pixelart on the graph screen. I read the entirety of [tibasicdev](http://tibasicdev.wikidot.com/home) and knew tons of tricks and hacks to make Ti-BASIC slightly faster (since the language was interpreted, this often involved removing characters and shortening code, also making it less legible in the process on top of the already obfuscating one-letter variables). I even made a [series of tutorials](https://drive.google.com/open?id=0ByPJCYXmeNcZN19ZOUZkWi1vajg) with sample problems and solutions in Google Drive and convinced some younger folk to stay after school so I could teach them how to *harness the power* of their calculator.

I wanted to make a full-fledged game and my friend [Ed Ho](https://edho-design.github.io) who was really into rhythm games asked me if it was possible to make one on the calculator. And thus CALCHERO was born (kind of). The idea would have been to make a [Guitar Hero](https://en.wikipedia.org/wiki/Guitar_Hero_III:_Legends_of_Rock) clone for the Ti-8X calculator, and the top 5 buttons would be the keys of the guitar, with the Enter button used to strum. Finally, it would in theory write music data to the port in real time that could be played on speakers or earphones. Yeah, it was a bold idea but I was determined. I tried at first to use Ti-BASIC but it's hard to draw even the simplest moving sprites and the music aspect was all but impossible without a more powerful language. 

I turned my sights on the [Zilog Z80](https://www.digikey.com/catalog/en/partgroup/z80/15507), the processor at the center of the Ti-8X Calculators. I had seen some crazy things implemented in Z80 assembly, and the Ti-8X calculators have a helpful set of commands that allow for writing, compiling, and running Z80 assembly programs: AsmPrgm, AsmCmp(), and Asm(). I knew that if this Super Smash Bros. "port" was possible, then surely I could get CALCHERO to work. so I read [*Learn Ti-83 Plus Assembly in 28 Days*](https://tutorials.eeems.ca/ASMin28Days/lesson/toc.html), and I learned a lot about how assembly works. But I was a bit in over my head at the time, and the end of the school year came and going off to college, I got distracted and dropped the project.

Fast-forward 3.5 years and I still love assembly and programming in general, and I'm arguably better at managing time to work on projects. So I sat down and finally reread 28 Days, and set up a programming environment for Ti-8X Z80 Assembly. This time, I have a much less long-term goal: complete *some* [Project Euler](https://projecteuler.net/) problems using Z80 Assembly. Obviously, I won't be able to do all of them since some require having a massive amount of storage / clock speed (neither of which is abundant for the Ti-8X calculators), but I think that attempting to solve a handful of these problems will help me hone my assembly programming skills.

The rest of this post will outline my programming environment on my Ubuntu 16.04 laptop, but I'm sure you could adapt it for other Linux machines easily. You'd probably have to find a different assembler ([TASM](https://www.ticalc.org/archives/files/fileinfo/250/25051.html)) and emulator ([WabbitEmu](http://wabbitemu.org/)) for support on Win/Mac.

First, I will need an assembler to convert the .z80 files (or .asm if you prefer to name them so) into binaries that can be run on the microprocessor. I wanted a modern one that was open-source, so if there were any issues I could easily check out the code and figure out what was going on (because not a lot of people do this nowadays so most forums are pretty much dead). I settled on [SPASM-ng](https://github.com/alberthdev/spasm-ng), an updated fork of the older [SPASM](http://www.jaymoseley.com/hercules/compilers/spasm.htm) assembler that has support for [eZ80](https://www.zilog.com/index.php?option=com_product&task=product&businessLine=1&id=77&parent_id=77&Itemid=57) now and fixed some bugs according to their README. There wasn't a lot of documentation on their GitHub about the project, so since it was open source, I figured I'd write my own and in the process learn how the assembler works. I covered all the assembler directives and pre-processor commands, and it was pretty fun reverse-engineering their code to figure out how they all worked without any documentation.

The Ti-8X runs Z80 binaries (.bin) on the actual calculators, but in order to send them to the device, they need to be packed in the correct .8XX file type, corresponding to the model of calculator you're actually trying to send it to. I found a universal python script called [BinPac8x](https://www.ticalc.org/archives/files/fileinfo/429/42915.html) by Kerm Martian from [Cemetech](https://www.cemetech.net/) that takes any Z80 binary and packages it according to the specified calculator type, and according to [this](http://merthsoft.com/linkguide/ti83+/fformat.html) file header format specification, I pared down the script so it just worked for the Ti84+ so I could more easily see what it was doing (obviously, I could have just used Martian's version, but I wanted to understand how it worked so I didn't accidentally brick my calculator.

Finally, I want to be able to test the programs on an emulator, ideally with some way of debugging the system, which should include the ability to look at registers / RAM and step through code during operation. I tried several options including WabbitEmu but eventually settled on [TilEm2](http://lpg.ticalc.org/prj_tilem/), the Ti Linux Emulator.